/* @flow */

export type Event<V> =
  {type: 'value', value: V} |
  {type: 'error', value: any} |
  {type: 'end', value: void};

export type Emitter<V> = {
  value(value: V): boolean;
  event(event: Event<V>): boolean;
  error(e: any): boolean;
  end(): void;

  // Deprecated methods
  emit(value: V): boolean;
  emitEvent(event: Event<V>): boolean;
};

export type Subscription = {
  closed: boolean;
  unsubscribe(): void;
};

export type Observer<V> = {
  value(value: V): void;
  error(err: any): void;
  end(): void;
};

declare class Observable<+V> {
  toProperty(): Property<V>;
  toProperty<V2>(getCurrent: ?() => V2): Property<V|V2>;
  changes(): Observable<V>;

  observe(obs: Observer<V>): Subscription;
  observe(onValue: ?(v: V) => void, onError: ?(err: any) => void, onEnd: ?() => void): Subscription;
  onValue(cb: (v: V) => void): Observable<V>;
  offValue(cb: (v: V) => void): Observable<V>;
  onError(cb: (err: any) => void): Observable<V>;
  offError(cb: (err: any) => void): Observable<V>;
  onEnd(cb: () => void): Observable<V>;
  offEnd(cb: () => void): Observable<V>;
  onAny(cb: (event: Event<V>) => void): Observable<V>;
  offAny(cb: (event: Event<V>) => void): Observable<V>;
  log(name?: string): Observable<V>;
  offLog(name?: string): Observable<V>;
  toPromise(PromiseConstructor?: Function): Promise<V>;

  map<V2>(cb: (v: V) => V2): Observable<V2>;
  filter(cb?: (v: V) => any): Observable<V>;
  take(n: number): Observable<V>;
  takeWhile(cb?: (v: V) => boolean): Observable<V>;
  last(): Observable<V>;
  skip(n: number): Observable<V>;
  skipWhile(cb?: (v: V) => boolean): Observable<V>;
  skipDuplicates(comparator?: (a: V, b: V) => boolean): Observable<V>;
  diff(fn?: (prev: V, next: V) => V, seed?: V): Observable<V>;
  diff<V2>(fn: (prev: V2, next: V) => V, seed: V2): Observable<V2>;
  scan(cb: (prev: V, next: V) => V, seed?: V): Observable<V>;
  scan<V2>(cb: (prev: V2, next: V) => V2, seed: V2): Observable<V2>;
  flatten(): Observable<any>;
  flatten<V2>(transformer: (value: V) => V2[]): Observable<V2>;
  delay(n: number): Observable<V>;
  throttle(n: number, options?: {leading?: boolean, trailing?: boolean}): Observable<V>;
  debounce(n: number, options?: {immediate?: boolean}): Observable<V>;
  mapErrors(fn: (error: any) => any): Observable<V>;
  filterErrors(fn: (error: any) => any): Observable<V>;
  takeErrors(n: number): Observable<V>;
  ignoreValues(): Observable<any>;
  ignoreErrors(): Observable<V>;
  ignoreEnd(): Observable<V>;
  beforeEnd<V2>(fn: () => V2): Observable<V|V2>;
  slidingWindow(max: number, min?: number): Observable<V[]>;
  bufferWhile(predicate?: (value: V) => boolean, options?: {flushOnEnd?: boolean}): Observable<V[]>;
  transduce(transducer: any): Observable<any>;
  withHandler<V2>(handler: (emitter: Emitter<V2>, event: Event<V>) => void): Observable<V2>;

  combine<V2>(otherObs: Observable<V2>): Observable<[V,V2]>;
  combine<V2,V3>(otherObs: Observable<V2>, combinator: (v: V, v2: V2) => V3): Observable<V3>;
  zip<V2>(otherObs: Observable<V2>): Observable<[V,V2]>;
  zip<V2,V3>(otherObs: Observable<V2>, combinator: (v: V, v2: V2) => V3): Observable<V3>;
  merge<V2>(otherObs: Observable<V2>): Observable<V|V2>;
  concat<V2>(otherObs: Observable<V2>): Observable<V|V2>;

  flatMap<V2>(transform: (value: V) => Observable<V2>): Observable<V2>;
  flatMapLatest<V2>(transform: (value: V) => Observable<V2>): Observable<V2>;
  flatMapFirst<V2>(transform: (value: V) => Observable<V2>): Observable<V2>;
  flatMapConcat<V2>(transform: (value: V) => Observable<V2>): Observable<V2>;
  flatMapLimit<V2>(transform: (value: V) => Observable<V2>, limit: number): Observable<V2>;
  flatMapErrors<V2>(transform: (error: any) => Observable<V2>): Observable<V|V2>;

  filterBy(otherObs: Observable<any>): Observable<V>;
  skipUntilBy(otherObs: Observable<any>): Observable<V>;
  takeUntilBy(otherObs: Observable<any>): Observable<V>;
  bufferBy(otherObs: Observable<any>, options?: {flushOnEnd?: boolean}): Observable<V[]>;
  bufferWhileBy(otherObs: Observable<any>, options?: {flushOnEnd?: boolean, flushOnChange?: boolean}): Observable<V[]>;
  sampledBy<V2>(otherObs: Observable<V2>): Observable<V>;
  sampledBy<V2,V3>(otherObs: Observable<V2>, combinator: (obsValue: V, otherObsValue: V2) => V3): Observable<V3>;
  bufferWithTimeOrCount(time: number, count: number, options?: {flushOnEnd: boolean}): Observable<V>;
}

declare class Pool<V> extends Observable<V> {
  plug(s: Observable<V>): () => void;
}

declare class Stream<V> extends Observable<V> {
}

declare class Property<V> extends Observable<V> {
}

declare var Kefir: {
  Observable: typeof Observable;
  Pool: typeof Pool;
  Stream: typeof Stream;
  Property: typeof Property;

  staticLand: {
    Observable: {
      ap: Function; //TODO replace Function with more specific types
      bimap: Function;
      chain<V,V2>(cb: (value: V) => Observable<V2>, s: Observable<V>): Observable<V2>;
      concat: Function;
      empty(): Observable<any>;
      map<V,V2>(cb: (value: V) => V2, s: Observable<V>): Observable<V2>;
      of<V>(value: V): Observable<V>;
    };
  };

  never(): Observable<any>;
  later<V>(delay: number, value: V): Observable<V>;
  interval<V>(interval: number, value: V): Observable<V>;
  sequentially<V>(interval: number, values: V[]): Observable<V>;
  fromPoll<V>(interval: number, f: () => V): Observable<V>;
  withInterval<V>(interval: number, f: (emitter: Emitter<V>) => void): Observable<V>;
  fromCallback<V>(f: (cb: (value: V) => void) => void): Observable<V>;
  fromNodeCallback<V>(f: (cb: (err: any, value: ?V) => void) => void): Observable<V>;
  fromEvents(target: Object, eventName: string, transformer?: (event: any) => any): Observable<any>;
  stream<V>(subscribe: (emitter: Emitter<V>) => ?() => void): Observable<V>;

  constant<V>(value: V): Observable<V>;
  constantError(err: any): Observable<any>;
  fromPromise<V>(promise: Promise<V>): Observable<V>;

  fromESObservable(observable: Object): Observable<any>;
  toESObservable(): Object;

  combine(obss: Observable<any>[], passiveObss?: Observable<any>[], combinator?: Function): Observable<any>;
  zip<V>(obss: Observable<V>[]): Observable<Array<V>>;
  zip(obss: Observable<any>[], combinator: Function): Observable<any>;
  merge<V>(obss: Observable<V>[]): Observable<V>;
  concat<V>(obss: Observable<V>[]): Observable<V>;

  pool(): Pool<*>;
  repeat<V>(fn: (i: number) => ?Observable<V>): Observable<V>;
};

module.exports = Kefir;
